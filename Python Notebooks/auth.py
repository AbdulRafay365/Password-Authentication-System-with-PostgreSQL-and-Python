# -*- coding: utf-8 -*-
"""auth

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GkLexGjIsmS8Kdm4Re-LNpmYLWSDRHZE

# **Password Authentication System with Neon Serverless Postgre and Python**
Simple and secure user authentication system with PostgreSQL and Python that supports user signup, login, password reset, and user management. It enforces strong password policies and protects user credentials using password hashing. The system provides clear feedback and ensures only unique usernames are registered, making authentication easy and safe.

**Importing the required Libraries**
"""

import gradio as gr
import bcrypt
import psycopg2
from psycopg2 import sql
import time
from datetime import datetime

"""### **Connect to the Database**"""

# Database connection setup
def get_connection():
    try:
        conn = psycopg2.connect(
            "postgresql://neondb_owner:npg_sgZ8bdtu7Wqy@ep-hidden-salad-a8mx9yqn-pooler.eastus2.azure.neon.tech/userpasswords?sslmode=require"
        )
        return conn
    except Exception as e:
        print(f"‚ö†Ô∏è Database connection failed: {e}")
        return None

print("‚úÖ Connected to Neon PostgreSQL")

"""### **Use this to clear tests (Use with precaution)**"""

def clear_test_data():
    """Clear previous test data"""
    conn = None
    try:
        conn = get_connection()
        if not conn:
            return False

        with conn.cursor() as cur:
            cur.execute("DELETE FROM users")
            conn.commit()
        print("üßπ Cleared previous test data")
        return True
    except Exception as e:
        print(f"‚ö†Ô∏è Error clearing test data: {e}")
        return False
    finally:
        if conn:
            conn.close()
clear_test_data()

"""### **Database Setup**"""

def setup_database():
    """Create the users table if it doesn't exist"""
    conn = None
    try:
        conn = get_connection()
        if not conn:
            return False

        with conn.cursor() as cur:
            # Create table with proper schema
            cur.execute("""
                CREATE TABLE IF NOT EXISTS users (
                    id SERIAL PRIMARY KEY,
                    username VARCHAR(50) UNIQUE NOT NULL,
                    password_hash VARCHAR(100) NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)
            conn.commit()
        print("‚úÖ Database table setup complete")
        return True
    except Exception as e:
        print(f"‚ö†Ô∏è Error setting up database: {e}")
        return False
    finally:
        if conn:
            conn.close()
setup_database()

"""### **Verify Database Contents**"""

def verify_database_contents():
    """Check what users exist in the database"""
    conn = None
    try:
        conn = get_connection()
        if not conn:
            return False

        with conn.cursor() as cur:
            cur.execute("SELECT username FROM users ORDER BY id ASC")
            users = cur.fetchall()
            if users:
                print("\nüìä DATABASE CONTENTS\n")
                for i, user in enumerate(users, 1):
                    print(f"{i}. {user[0]}")
            else:
                print("\nüìä Database is empty")
        return True
    except Exception as e:
        print(f"‚ö†Ô∏è Error verifying database: {e}")
        return False
    finally:
        if conn:
            conn.close()
verify_database_contents()

"""###**Signup Function**"""

def signup(username, password):
    """Signup function with validation and detailed rule-breaking messages"""
    conn = None
    try:
        # Password validation checks
        errors = []
        if len(password) < 8:
            errors.append("‚ùå Password too short (min 8 chars)")
        if not any(c.isupper() for c in password):
            errors.append("‚ùå Needs uppercase letter")
        if not any(c.islower() for c in password):
            errors.append("‚ùå Needs lowercase letter")
        if not any(c.isdigit() for c in password):
            errors.append("‚ùå Needs digit")
        if not any(c in '!@#$%^&*()_+-=[]{}|;:,.<>?/' for c in password):
            errors.append("‚ùå Needs special character")
        if ' ' in password:
            errors.append("‚ùå Contains spaces")
        if password.lower() in ['password', '12345678', 'qwerty', 'password123!']:
            errors.append("‚ùå Common password")
        if any(password.count(c) > 2 for c in set(password)):
            errors.append("‚ùå Too many repeating characters")

        if errors:
            return "\n".join(errors)  # Return detailed errors as a string

        # Hash password
        hashed = bcrypt.hashpw(password.encode(), bcrypt.gensalt())

        # Store in database
        conn = get_connection()
        if not conn:
            return "‚ùå Database connection error"

        with conn.cursor() as cur:
            cur.execute(
                sql.SQL("INSERT INTO users (username, password_hash) VALUES (%s, %s)"),
                (username, hashed.decode())
            )
            conn.commit()
        return "‚úÖ Signup successful!"

    except psycopg2.IntegrityError:
        return "‚ö†Ô∏è Username already exists"
    except Exception as e:
        return f"‚ö†Ô∏è Database error - {str(e)}"
    finally:
        if conn:
            conn.close()
            time.sleep(0.1)

"""### **Login Function**"""

def login(username, password):
    """Test login function"""
    conn = None
    try:
        conn = get_connection()
        if not conn:
            return "‚ö†Ô∏è Database Connection Error"

        with conn.cursor() as cur:
            cur.execute(
                sql.SQL("SELECT password_hash FROM users WHERE username = %s"),
                (username,)
            )
            result = cur.fetchone()

            if not result:
                print(f"‚ùå {username}: User not found")
                return "‚ö†Ô∏è User not found"

            hashed = result[0].encode()
            if bcrypt.checkpw(password.encode(), hashed):
                print(f"‚úÖ {username}: Login successful!")
                return "Login successful!"
            else:
                print(f"‚ùå {username}: Incorrect password")
                return "‚ùå Incorrect Password"
    except Exception as e:
        print(f"‚ö†Ô∏è {username}: Error - {str(e)}")
        return "‚ö†Ô∏è Error"
    finally:
        if conn:
            conn.close()

"""### **Run Tests**"""

def test_signup_case(username, password, should_pass):
    result = signup(username, password)
    passed = (should_pass and result.startswith("‚úÖ")) or (not should_pass and result.startswith("‚ùå"))
    status = "PASSED" if passed else "FAILED"

    print(f"Test signup('{username}', '{password}')")
    print(f"Result: {result}")
    print(f"Expected to {'PASS' if should_pass else 'FAIL'}, Test {status}\n")


def run_signup_tests():
    if not setup_database():
        print("üõë Critical error: Cannot setup database")
        return
    if not clear_test_data():
        print("üõë Critical error: Cannot clear test data")
        return

    print("\n=== SIGNUP TESTS ===")

    print("\nShould Fail (Password rule violations):")
    test_signup_case("fail1", "A1!", False)                   # Too short
    test_signup_case("fail2", "secure123!", False)            # No uppercase letter
    test_signup_case("fail3", "SECURE123!", False)            # No lowercase letter
    test_signup_case("fail4", "SecurePass!", False)           # No digit
    test_signup_case("fail5", "Secure1234", False)            # No special char
    test_signup_case("fail6", "Secure 123!", False)           # Contains space
    test_signup_case("fail7", "password123!", False)          # Common password
    test_signup_case("fail8", "Secureee123!", False)          # Too many repeats (3+ 'e's)
    test_signup_case("fail9", "12345678", False)              # Only numbers, no uppercase/lower/special
    test_signup_case("fail10", "!@#$%^&*", False)             # Only special chars, no letter/digit

    print("\nShould Pass (Valid passwords):")
    test_signup_case("valid1", "A1!bcdef", True)              # Min length, valid mix
    test_signup_case("valid2", "Secur3Pass!", True)           # Mixed case, digit, special
    test_signup_case("valid3", "Secure@123", True)            # Special char included
    test_signup_case("valid4", "P@ssw0rd!", True)             # Complex valid password
    test_signup_case("valid5", "VeryL0ngS3cureP@ss!", True)   # Long and complex
    test_signup_case("valid6", "Xk8#qB$z", True)              # Random mix
    test_signup_case("valid7", "Sec_ure123!", True)           # Underscore allowed
    test_signup_case("valid8", "Sec-ure123!", True)           # Hyphen allowed
    test_signup_case("valid9", "A1!@B2#c3$", True)            # Multiple specials
    test_signup_case("valid10", "V3ry$3cureP@ss!", True)      # Max complexity

# Run the tests if this script is executed directly
if __name__ == "__main__":
    run_signup_tests()

"""### **Duplicate Signup Test**"""

print("\n=== DUPLICATE USERNAME TESTS ===")
print("Attempting to sign up with the same valid usernames again:\n")

def test_duplicate_signup(username, password):
    result = signup(username, password)
    expected_fail = "‚ö†Ô∏è Username already exists"
    passed = (result == expected_fail)
    status = "PASSED" if passed else "FAILED"
    print(f"Trying to sign up again with username='{username}'")
    print(f"Result: {result}")
    print(f"Expected: {expected_fail}")
    print(f"Test {status}\n")

# Re-attempt signup for previously created valid users
test_duplicate_signup("valid1", "A1!bcdef")
test_duplicate_signup("valid2", "DifferentPass1!")
test_duplicate_signup("valid3", "Secur3Pass!")
test_duplicate_signup("valid4", "P@ssw0rd!")
test_duplicate_signup("valid5", "VeryL0ngS3cureP@ss!")

print("Verifying database contents (should be unchanged):\n")
verify_database_contents()

def list_users():
    """List all users in the database"""
    conn = None
    try:
        conn = get_connection()
        if not conn:
            return "‚ö†Ô∏è Database connection failed"

        with conn.cursor() as cur:
            cur.execute("SELECT username, created_at FROM users ORDER BY created_at DESC")
            users = cur.fetchall()
            if users:
                return "\n".join([f"- {user[0]} (since {user[1].strftime('%Y-%m-%d %H:%M')})" for user in users])
            else:
                return "Database is empty"
    except Exception as e:
        return f"‚ö†Ô∏è Error: {str(e)}"
    finally:
        if conn:
            conn.close()

list_users()

"""### **Helper Functions**"""

# --- Helper Functions ---
def password_strength(password):
    """Returns a strength score (0-100) based on rules met"""
    score = 0
    if len(password) >= 8: score += 20
    if any(c.isupper() for c in password): score += 15
    if any(c.islower() for c in password): score += 15
    if any(c.isdigit() for c in password): score += 15
    if any(c in '!@#$%^&*()_+-=[]{}|;:,.<>?/' for c in password): score += 15
    if ' ' not in password: score += 10
    if password.lower() not in ['password', '12345678', 'qwerty', 'password123!']: score += 5
    if not any(password.count(c) > 2 for c in set(password)): score += 5
    return min(score, 100)

def toggle_password(show):
    return gr.update(type="text" if show else "password")

"""### **Reset Passwords**"""

def reset_password(username):
    """Reset the password to a temporary one for a user in the PostgreSQL database."""
    conn = None
    try:
        conn = get_connection()
        if not conn:
            return "‚ùå Database connection error"

        with conn.cursor() as cur:
            cur.execute("SELECT username FROM users WHERE username = %s", (username,))
            if not cur.fetchone():
                return "‚ùå Username not found"

            # Set temporary password
            temp_password = "TempPass123!"
            hashed = bcrypt.hashpw(temp_password.encode(), bcrypt.gensalt())

            cur.execute(
                "UPDATE users SET password_hash = %s WHERE username = %s",
                (hashed.decode(), username)
            )
            conn.commit()
            return f"‚úÖ Temporary password set to: {temp_password}"

    except Exception as e:
        return f"‚ö†Ô∏è Error resetting password: {str(e)}"
    finally:
        if conn:
            conn.close()

"""###**Test Password Strength**"""

password_strength("Str0ng!9")